//! Web server to accept the temporary code from GitHub

use std::net::SocketAddr;
use std::path::Path;

use anyhow::{Context, Error};
use axum::extract::{Query, State};
use axum::response::IntoResponse;
use axum::routing::get;
use axum::Router;
use serde::Deserialize;
use tokio::net::TcpListener;
use tokio::sync::mpsc::{channel, Receiver, Sender};
use url::Url;

use crate::manifest::{Manifest, SerializedManifest};
use crate::register::form::Form;

/// Query parameters for the temporary code callback
///
/// This struct is used to deserialize the query parameters from the temporary code callback. The
/// callback is called after the user has registered a new GitHub App from a manifest, and can be
/// used to get the app's private key and secrets from GitHub.
#[derive(Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Default, Deserialize)]
struct Params {
    /// The temporary code returned by GitHub
    code: String,
}

/// Application state for the axum server
///
/// The state for the axum server includes a channel to send the temporary code to, and the manifest
/// that was generated with the local address.
#[derive(Clone, Debug)]
struct AppState {
    /// The channel to which to send the temporary code
    channel: Sender<String>,

    /// The endpoint of the GitHub API
    github: Url,

    /// The manifest to register the GitHub App
    manifest: SerializedManifest,
}

/// Start a web server on a background thread
///
/// This function starts a web server that accepts the temporary code from GitHub when a new GitHub
/// App is registered. The server listens on a random port and sends the temporary code to a channel
/// for further processing.
///
/// The server runs in a background task as to not block the main thread.
pub async fn start_background_web_server(
    manifest_path: &Path,
    github: Url,
    port: Option<u16>,
) -> Result<(SocketAddr, Receiver<String>), Error> {
    // Either use the given port or let the OS choose a random port
    let interface = format!("127.0.0.1:{}", port.unwrap_or(0));
    let listener = TcpListener::bind(interface.parse::<SocketAddr>().unwrap()).await?;
    let addr = listener.local_addr()?;

    let manifest = generate_and_serialize_manifest(manifest_path, &addr)?;
    let (sender, receiver) = channel(1);

    let _server = tokio::spawn(run_axum_server(sender, listener, github, manifest));

    Ok((addr, receiver))
}

/// Generate the manifest
///
/// The manifest is generated by reading the manifest file that is passed to the CLI as an
/// argument, and then overwriting the `redirect_url` with the address of the local web server.
fn generate_and_serialize_manifest(
    manifest_path: &Path,
    addr: &SocketAddr,
) -> Result<SerializedManifest, Error> {
    let mut manifest = Manifest::from_file(manifest_path)?;

    let redirect_url = format!("http://{}:{}/callback", addr.ip(), addr.port()).into();
    manifest.set_redirect_url(Some(redirect_url));

    manifest.try_into()
}

/// Start the axum server to accept the temporary code
///
/// This function starts an axum server that listens for a POST request on the root path. The server
/// will accept the temporary code from the query parameters and send it to a channel for further
/// processing.
///
/// Spawn this function in a tokio task to start the server in the background.
async fn run_axum_server(
    channel: Sender<String>,
    listener: TcpListener,
    github: Url,
    manifest: SerializedManifest,
) -> Result<(), Error> {
    let app = Router::new()
        .route("/", get(show_form))
        .route("/callback", get(accept_temporary_code))
        .with_state(AppState {
            channel,
            github,
            manifest,
        });

    axum::serve(listener, app)
        .await
        .context("failed to start axum server")?;

    Ok(())
}

/// Render the form that starts the registration process
///
/// This function renders the form that is used to start the registration process for a new GitHub
/// App. The form includes the manifest that was generated from the manifest file.
async fn show_form(state: State<AppState>) -> impl IntoResponse {
    Form::new(state.github.clone(), state.manifest.clone())
}

/// Handle the callback after registering a new GitHub App
///
/// After registering a new GitHub App from a manifest, GitHub will redirect the user back to a
/// callback URL. The redirect includes a temporary code that can be exchanged for the app's private
/// key and secrets. This function accepts the temporary code and sends it to a channel for further
/// processing.
async fn accept_temporary_code(state: State<AppState>, query: Query<Params>) {
    state.channel.send(query.code.clone()).await.unwrap()
}

#[cfg(test)]
mod tests {
    use std::io::Write;
    use std::str::FromStr;

    use indoc::indoc;
    use pretty_assertions::assert_eq;
    use reqwest::Client;
    use tempfile::NamedTempFile;

    use super::*;

    #[test]
    fn generate_manifest_overwrites_redirect_url() {
        let manifest = indoc! {r#"
            {
                "url": "https://www.example.com",
                "redirect_url": "https://example.com/redirect"
            }
        "#};
        let mut file = NamedTempFile::new().unwrap();
        file.write_all(manifest.as_bytes()).unwrap();

        let addr = SocketAddr::from_str("127.0.0.1:8080").unwrap();

        let serialized_manifest = generate_and_serialize_manifest(file.path(), &addr).unwrap();
        let manifest: Manifest = serde_json::from_str(serialized_manifest.get()).unwrap();

        assert_eq!(
            &Some("http://127.0.0.1:8080/callback".into()),
            manifest.redirect_url()
        );
    }

    #[test]
    fn generate_manifest_errors_on_missing_file() {
        let file = Path::new("missing-file.json");
        let addr = SocketAddr::from_str("127.0.0.1:8080").unwrap();

        let error = generate_and_serialize_manifest(file, &addr).unwrap_err();

        assert_eq!("failed to read manifest file", error.to_string());
    }

    #[tokio::test]
    async fn show_form_renders_form() {
        let manifest = indoc! {r#"
            {
                "url": "https://www.example.com"
            }
        "#};
        let mut file = NamedTempFile::new().unwrap();
        file.write_all(manifest.as_bytes()).unwrap();

        let (addr, _receiver) = start_background_web_server(
            file.path(),
            Url::parse("https://api.github.com").unwrap(),
            None,
        )
        .await
        .unwrap();
        let callback_url = format!("http://{}/callback", addr);

        let body = Client::new()
            .get(format!("http://{}/", addr))
            .send()
            .await
            .expect("failed to execute GET /request")
            .text()
            .await
            .unwrap();

        assert!(body.contains(&callback_url));
    }

    #[tokio::test]
    async fn accept_temporary_code_sends_code_to_channel() {
        let manifest = indoc! {r#"
            {
                "url": "https://www.example.com"
            }
        "#};
        let mut file = NamedTempFile::new().unwrap();
        file.write_all(manifest.as_bytes()).unwrap();

        let (addr, mut receiver) = start_background_web_server(
            file.path(),
            Url::parse("https://api.github.com").unwrap(),
            None,
        )
        .await
        .unwrap();

        let _response = Client::new()
            .get(format!(
                "http://{}/callback?code=otters-are-the-cutest",
                addr
            ))
            .send()
            .await
            .expect("failed to execute GET /callback request");

        assert_eq!(Some("otters-are-the-cutest".into()), receiver.recv().await);
    }
}
