//! Command to register a new GitHub App

use std::net::SocketAddr;

use anyhow::Error;
use async_trait::async_trait;

use crate::cli::Args;
use crate::manifest::Manifest;
use crate::register::server::spawn_web_server_on_background_thread;
use crate::register::RegisterArgs;
use crate::Execute;

/// Register a new GitHub App
///
/// This command is used to register a new GitHub App from a manifest file. The manifest file must
/// be provided as an argument to the command. The command will parse the manifest, optionally
/// customize it, and then register the app with GitHub.
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug)]
pub struct RegisterCommand<'a> {
    /// The arguments for the command
    args: &'a RegisterArgs,
}

impl<'a> RegisterCommand<'a> {
    /// Create a new instance of the command
    pub fn new(args: &'a RegisterArgs) -> Self {
        Self { args }
    }

    /// Generate the manifest
    ///
    /// The manifest is generated by reading the manifest file that is passed to the CLI as an
    /// argument, and then overwriting the `redirect_url` with the address of the local web server.
    fn generate_manifest(&self, addr: &SocketAddr) -> Result<Manifest, Error> {
        let mut manifest = Manifest::from_file(self.args.manifest())?;

        let redirect_url = format!("http://{}:{}/", addr.ip(), addr.port()).into();
        manifest.set_redirect_url(Some(redirect_url));

        Ok(manifest)
    }
}

#[async_trait]
impl<'a> Execute for RegisterCommand<'a> {
    async fn execute(&self, _global_args: &Args) -> Result<(), Error> {
        let (addr, _receiver) = spawn_web_server_on_background_thread().await;
        let manifest = self.generate_manifest(&addr)?;

        println!("{}", serde_json::to_string(&manifest)?);

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use std::io::Write;
    use std::str::FromStr;

    use indoc::indoc;
    use pretty_assertions::assert_eq;
    use tempfile::NamedTempFile;

    use super::*;

    #[test]
    fn generate_manifest_overwrites_redirect_url() {
        let manifest = indoc! {r#"
            {
                "url": "https://www.example.com",
                "redirect_url": "https://example.com/redirect"
            }
        "#};
        let mut file = NamedTempFile::new().unwrap();
        file.write_all(manifest.as_bytes()).unwrap();

        let args = RegisterArgs::builder().manifest(file.path()).build();
        let command = RegisterCommand::new(&args);
        let addr = SocketAddr::from_str("127.0.0.1:8080").unwrap();

        let manifest = command.generate_manifest(&addr).unwrap();

        assert_eq!(
            &Some("http://127.0.0.1:8080/".into()),
            manifest.redirect_url()
        );
    }

    #[test]
    fn generate_manifest_errors_on_missing_file() {
        let args = RegisterArgs::builder().manifest("missing.json").build();
        let command = RegisterCommand::new(&args);
        let addr = SocketAddr::from_str("127.0.0.1:8080").unwrap();

        let error = command.generate_manifest(&addr).unwrap_err();

        assert_eq!("failed to read manifest file", error.to_string());
    }

    #[test]
    fn trait_send() {
        fn assert_send<T: Send>() {}
        assert_send::<RegisterCommand>();
    }

    #[test]
    fn trait_sync() {
        fn assert_sync<T: Sync>() {}
        assert_sync::<RegisterCommand>();
    }

    #[test]
    fn trait_unpin() {
        fn assert_unpin<T: Unpin>() {}
        assert_unpin::<RegisterCommand>();
    }
}
